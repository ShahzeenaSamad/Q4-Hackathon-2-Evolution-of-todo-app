---
description: "Create implementation plan from feature specification"
---

# Implementation Plan Command

## Usage
```
/sp.plan <feature-name>
```

## Description
Creates a detailed technical plan for implementing a feature, based on the feature specification.

## Prerequisites
- Feature spec MUST exist at `specs/<feature-name>/spec.md`
- Spec MUST have approved user stories and requirements

## Plan Structure

### 1. Summary
Extract from feature spec: primary requirement + technical approach

### 2. Technical Context
- **Language/Version**: e.g., Python 3.13, Next.js 16+
- **Primary Dependencies**: e.g., FastAPI, SQLModel, Neon DB
- **Storage**: e.g., PostgreSQL, files, in-memory
- **Testing**: e.g., pytest, Jest
- **Target Platform**: e.g., Linux server, Vercel, Kubernetes
- **Project Type**: single/web/mobile
- **Performance Goals**: e.g., p95 latency < 500ms
- **Constraints**: e.g., memory limits, offline capability
- **Scale/Scope**: e.g., 10k users, 100 req/s

### 3. Constitution Check
GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.
Verify compliance with:
- Spec-Driven Development
- Stateless & Cloud-Native Design
- Security by Design
- Observability & Scalability

### 4. Project Structure
Define code organization:
- Single project: `src/`, `tests/`
- Web app: `backend/src/`, `frontend/src/`
- Mobile: `api/`, `ios/`, `android/`

### 5. Complexity Tracking
If constitution violations exist, document justification:
| Violation | Why Needed | Simpler Alternative Rejected Because |

## Output Files
```
specs/<feature-name>/
├── spec.md              # Feature specification (prerequisite)
├── plan.md              # Implementation plan (this command)
├── research.md          # Phase 0: Technical research
├── data-model.md        # Phase 1: Data models
├── quickstart.md        # Phase 1: Quick start guide
├── contracts/           # Phase 1: API/DB contracts
└── tasks.md             # Generated by /sp.tasks
```

## Implementation Phases

### Phase 0: Research
- Explore technical options
- Evaluate dependencies
- Document trade-offs
- Output: `research.md`

### Phase 1: Design
- Define data models
- Design API contracts
- Create quickstart guide
- Output: `data-model.md`, `quickstart.md`, `contracts/`

### Phase 2: Tasks (via /sp.tasks)
- Break down into implementable tasks
- Organize by user story
- Mark parallel opportunities

## Example Usage

### Plan Simple Feature
```
/sp.plan task-crud
```
Creates implementation plan for basic task CRUD.

### Plan Complex Feature
```
/sp.plan chatbot
```
Creates comprehensive plan for AI chatbot with MCP tools.

## Constitution Compliance

### Spec-Driven Development
✅ Plan based on approved spec
✅ Technical approach documented
✅ Dependencies identified

### Human as System Architect
✅ Architect makes technical decisions
✅ Trade-offs documented in research
✅ Complexity justified if needed

### Stateless & Cloud-Native Design
✅ State management strategy defined
✅ External state storage identified
✅ Cloud-native requirements met

## Validation Checklist
Before plan complete:
- [ ] Technical context fully defined
- [ ] Constitution check passed (or violations justified)
- [ ] Project structure decided
- [ ] All phases outlined
- [ ] Dependencies listed
- [ ] Performance goals set
- [ ] Constraints documented

## Templates Used
- `specs/<feature-name>/plan.md` follows `.specify/templates/plan-template.md`

## See Also
- `/sp.spec` - Create feature specification
- `/sp.tasks` - Generate task breakdown
- `/sp.constitution` - View governing principles
- `/sp.adr` - Document architectural decisions
